{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>Aioinject is a dependency injection and service locator library, made to easily work with dependency injection using python type annotations.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install with pip or your favorite package manager: <pre><code>pip install aioinject\n</code></pre></p>"},{"location":"#example","title":"Example","text":"<pre><code>import aioinject\n\n\nclass Database:\n    def __init__(self) -&gt; None:\n        self._storage = {1: \"Username\"}\n\n    def get(self, id: int) -&gt; str | None:\n        return self._storage.get(id)\n\n\nclass UserService:\n    def __init__(\n        self,\n        database: Database,  # &lt;- Aioinject would try to inject `Database` here\n    ) -&gt; None:\n        self._database = database\n\n    def get(self, id: int) -&gt; str:\n        user = self._database.get(id)\n        if user is None:\n            raise ValueError\n        return user\n\n\ncontainer = aioinject.Container()\ncontainer.register(\n    aioinject.Singleton(Database),\n    aioinject.Singleton(UserService),\n)\n\nwith container.sync_context() as ctx:\n    service = ctx.resolve(UserService)\n    user = service.get(1)\n    assert user == \"Username\"\n    print(user)\n</code></pre>"},{"location":"context-managers/","title":"Context manager dependencies","text":"<p>Dependencies can use  <code>@contextlib.contextmanager</code> and <code>@contextlib.asynccontextmanager</code> decorators to execute code during their init and shutdown.</p>"},{"location":"context-managers/#implementation","title":"Implementation","text":"<p>Internally aioinject uses contextlib.ExitStack and contextlib.AsyncExitStack</p>"},{"location":"context-managers/#providers","title":"Providers","text":""},{"location":"context-managers/#scoped-and-transient-providers","title":"Scoped and Transient providers","text":"<p>For <code>Scoped</code> and <code>Transient</code> providers dependencies will close when context is closed:</p> <pre><code>import contextlib\nfrom collections.abc import Iterator\n\nimport aioinject\nfrom aioinject import Scoped\n\n\n@contextlib.contextmanager\ndef dependency() -&gt; Iterator[int]:\n    print(\"Startup\")\n    yield 42\n    print(\"Shutdown\")\n\n\ncontainer = aioinject.Container()\ncontainer.register(Scoped(dependency))\n\nwith container.sync_context() as ctx:\n    print(ctx.resolve(int))  # Startup, 42\n# Shutdown\n</code></pre>"},{"location":"context-managers/#singleton-provider","title":"Singleton provider","text":"<p>In case of a <code>Singleton</code> they're closed when you close container itself:</p> <pre><code>import contextlib\nfrom collections.abc import Iterator\n\nimport aioinject\nfrom aioinject import Singleton\n\n\n@contextlib.contextmanager\ndef dependency() -&gt; Iterator[int]:\n    print(\"Startup\")\n    yield 42\n    print(\"Shutdown\")\n\n\ncontainer = aioinject.Container()\ncontainer.register(Singleton(dependency))\n\nwith container:\n    with container.sync_context() as ctx:\n        print(ctx.resolve(int))  # Startup, 42\n    print(\"Context is closed\")\n# Shutdown\n</code></pre>"},{"location":"context-managers/#using-your-own-or-3rd-party-class-as-a-context-manager","title":"Using your own or 3rd party class as a context manager","text":"<p>Even if your class has <code>__enter__</code> and <code>__exit__</code> methods it won't implicitly be used as a context manager:</p> <p><pre><code>from types import TracebackType\n\nfrom typing_extensions import Self\n\nimport aioinject\nfrom aioinject import Scoped\n\n\nclass Class:\n    def __enter__(self) -&gt; Self:\n        print(\"Startup\")\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        print(\"Shutdown\")\n\n\ncontainer = aioinject.Container()\ncontainer.register(Scoped(Class))\n\nwith container.sync_context() as ctx:\n    print(ctx.resolve(Class))  # &lt;__main__.Class object at ...&gt;\n</code></pre> Nothing is printed! You have to explicitly create a function and decorate it with contextlib decorator:</p> <pre><code>@contextlib.contextmanager\ndef create_class() -&gt; Class:\n    with Class() as cls:\n        yield cls\n</code></pre>"},{"location":"cookbook/","title":"Cook Book","text":""},{"location":"cookbook/#pydantic-settings","title":"Pydantic Settings","text":"<p>Adding pydantic settings to a container: <pre><code>from collections.abc import Sequence\n\nfrom pydantic import PostgresDsn\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\nimport aioinject\n\n\nclass AppSettings(BaseSettings):\n    model_config = SettingsConfigDict(env_prefix=\"app_\")\n\n    version: str\n    site_url: str\n\n\nclass DatabaseSettings(BaseSettings):\n    model_config = SettingsConfigDict(env_prefix=\"database_\")\n\n    url: PostgresDsn\n\n\n_settings_classes: Sequence[type[BaseSettings]] = [\n    AppSettings,\n    DatabaseSettings,\n]\n\n\ndef create_container() -&gt; aioinject.Container:\n    container = aioinject.Container()\n\n    for settings_cls in _settings_classes:\n        # Type is inferred from the instance passed into \"Object\"\n        container.register(aioinject.Object(settings_cls()))\n\n    return container\n</code></pre></p>"},{"location":"extensions/","title":"Extensions","text":"<p>Extensions are a mechanism to extend container and context behavior, similar to a plugin system.</p>"},{"location":"extensions/#container-extensions","title":"Container Extensions","text":""},{"location":"extensions/#lifespan","title":"Lifespan","text":"<p>Lifespan extension could be used to execute code when container enters and exits <pre><code>import asyncio\nimport contextlib\nfrom collections.abc import AsyncIterator\n\nfrom aioinject import Container\nfrom aioinject.extensions import LifespanExtension\n\n\nclass MyLifespanExtension(LifespanExtension):\n    @contextlib.asynccontextmanager\n    async def lifespan(\n        self,\n        container: Container,  # noqa: ARG002\n    ) -&gt; AsyncIterator[None]:\n        print(\"Enter\")\n        yield None\n        print(\"Exit\")\n\n\nasync def main() -&gt; None:\n    container = Container(extensions=[MyLifespanExtension()])\n    async with container:\n        # print(\"Enter\") is executed.\n        pass\n        # print(\"Exit\") is executed.\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p>"},{"location":"extensions/#oninit","title":"OnInit","text":"<p>OnInit extension is executed when container's <code>__init__</code> is called, this could be used for example to register dependencies in it: <pre><code>from datetime import datetime\nfrom typing import NewType\n\nfrom aioinject import Container, Transient\nfrom aioinject.extensions import OnInitExtension\n\n\nNow = NewType(\"Now\", datetime)\n\n\nclass TimeExtension(OnInitExtension):\n    def on_init(\n        self,\n        container: Container,\n    ) -&gt; None:\n        container.register(Transient(datetime.now, Now))\n\n\ncontainer = Container(extensions=[TimeExtension()])\nwith container.sync_context() as ctx:\n    print(ctx.resolve(Now))\n</code></pre></p>"},{"location":"extensions/#context-extensions","title":"Context Extensions","text":"<p>Context extensions can be added to individual contexts when creating them <pre><code>async with container.context(\n    extensions=[MyContextExtension()],\n):\n    pass\n</code></pre></p>"},{"location":"extensions/#onresolve-onresolvesync","title":"OnResolve / OnResolveSync","text":"<p>On resolve extension is called when individual dependency is provided within a context: <pre><code>import logging\nfrom typing import TypeVar\n\nfrom aioinject import InjectionContext, Provider\nfrom aioinject.extensions import OnResolveExtension\n\n\nT = TypeVar(\"T\")\n\n\nclass MyExtension(OnResolveExtension):\n    async def on_resolve(\n        self,\n        context: InjectionContext,  # noqa: ARG002\n        provider: Provider[T],\n        instance: T,  # noqa: ARG002\n    ) -&gt; None:\n        logging.info(\"%s type was provided!\", provider.type_)\n</code></pre></p>"},{"location":"providers/","title":"Providers","text":"<p>Aioinject implements multiple different providers,  they work similarly to service lifetimes in other libraries, such as DI in .NET Core</p>"},{"location":"providers/#scoped","title":"Scoped","text":"<p>Objects provided with <code>Scoped</code> provider would be cached within context. <pre><code>import aioinject\n\n\ncontainer = aioinject.Container()\ncontainer.register(aioinject.Scoped(list))\n\nwith container.sync_context() as ctx:\n    object_1 = ctx.resolve(list)\n    object_2 = ctx.resolve(list)\n    assert object_1 is object_2\n</code></pre></p>"},{"location":"providers/#transient","title":"Transient","text":"<p><code>Transient</code> provider would provide different instances even if used within same context  <pre><code>import aioinject\n\n\ncontainer = aioinject.Container()\ncontainer.register(aioinject.Transient(list))\n\nwith container.sync_context() as ctx:\n    object_1 = ctx.resolve(list)\n    object_2 = ctx.resolve(list)\n    assert object_1 is not object_2\n</code></pre></p>"},{"location":"providers/#singleton","title":"Singleton","text":"<p><code>Singleton</code> works as you expect - there would be only one instance of a singleton object, bound to a specific container <pre><code>import aioinject\n\n\ncontainer = aioinject.Container()\ncontainer.register(aioinject.Singleton(list))\n\nwith container.sync_context() as ctx:\n    object_1 = ctx.resolve(list)\n\nwith container.sync_context() as ctx:\n    object_2 = ctx.resolve(list)\n\nassert object_1 is object_2\n</code></pre></p>"},{"location":"providers/#object","title":"Object","text":"<p><code>Object</code> provider just returns an object provided to it: <pre><code>aioinject.Object(42)\n</code></pre> would always return 42</p>"},{"location":"integrations/aiogram/","title":"Aiogram","text":"<p>Aiogram integration is achieved with <code>AioInjectMiddleware</code>, which you could register on individual observers or on all observers in a router via <code>add_to_router</code> method:</p> <pre><code>import asyncio\n\nfrom aiogram import Bot, Dispatcher, Router\nfrom aiogram.filters import Command\nfrom aiogram.types import Message\nfrom benchmark.container import create_container\n\nfrom aioinject import Injected, Object\nfrom aioinject.ext.aiogram import AioInjectMiddleware, inject\n\n\nasync def main() -&gt; None:\n    dispatcher = Dispatcher()\n\n    container = create_container()\n    container.register(Object(42))\n\n    router = Router()\n\n    @router.message(\n        Command(commands=[\"start\"]),\n    )\n    @inject\n    async def start(\n        message: Message,\n        value: Injected[int],\n    ) -&gt; None:\n        await message.reply(f\"Injected value is {value}\")\n\n    middleware = AioInjectMiddleware(container)\n    middleware.add_to_router(router)\n\n    dispatcher.include_router(router)\n\n    async with (\n        container,\n        Bot(token=\"token-here\") as bot,  # noqa: S106\n    ):\n        await dispatcher.start_polling(bot)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"integrations/fastapi/","title":"FastAPI","text":"<p>To integrate with FastAPI you need to add a <code>AioinjectMiddleware</code> and optionally a lifespan if you use context manager dependencies: <pre><code>import contextlib\nfrom collections.abc import AsyncIterator\n\nimport uvicorn\nfrom fastapi import FastAPI\n\nimport aioinject\nfrom aioinject import Injected\nfrom aioinject.ext.fastapi import AioInjectMiddleware, inject\n\n\ncontainer = aioinject.Container()\ncontainer.register(aioinject.Object(42))\n\n\n@contextlib.asynccontextmanager\nasync def lifespan(_: FastAPI) -&gt; AsyncIterator[None]:\n    async with container:\n        yield\n\n\ndef create_app() -&gt; FastAPI:\n    app = FastAPI(lifespan=lifespan)\n    app.add_middleware(AioInjectMiddleware, container=container)\n\n    @app.get(\"/\")\n    @inject\n    async def root(number: Injected[int]) -&gt; int:\n        return number\n\n    return app\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:create_app\", factory=True, reload=True)\n</code></pre></p>"},{"location":"integrations/litestar/","title":"Litestar","text":"<p>Litestar integration comes with a plugin, you just need to add it to litestar app: <pre><code>import uvicorn\nfrom litestar import Litestar, get\n\nimport aioinject\nfrom aioinject import Injected\nfrom aioinject.ext.litestar import AioInjectPlugin, inject\n\n\ncontainer = aioinject.Container()\ncontainer.register(aioinject.Object(42))\n\n\n@get(\"/\")\n@inject\nasync def function_route(\n    number: Injected[int],\n) -&gt; int:\n    return number\n\n\ndef create_app() -&gt; Litestar:\n    return Litestar(\n        [function_route],\n        plugins=[AioInjectPlugin(container=container)],\n    )\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:create_app\", factory=True, reload=True)\n</code></pre></p>"},{"location":"integrations/strawberry-graphql/","title":"Strawberry GraphQL","text":"<p>Aioinject integrates with <code>strawberry-graphql</code> using a custom extension:</p> <pre><code>from typing import Any\n\nimport strawberry\nimport uvicorn\nfrom strawberry import Schema\nfrom strawberry.asgi import GraphQL\n\nimport aioinject\nfrom aioinject import Injected\nfrom aioinject.ext.strawberry import AioInjectExtension, inject  # (1)!\n\n\ncontainer = aioinject.Container()\ncontainer.register(aioinject.Object(42))\n\n\n@strawberry.type\nclass Query:\n    @strawberry.field\n    @inject\n    async def number(self, number: Injected[int]) -&gt; int:\n        return number\n\n\ndef create_app() -&gt; GraphQL[Any, Any]:\n    schema = Schema(\n        query=Query,\n        extensions=[\n            AioInjectExtension(container=container),\n        ],\n    )\n    return GraphQL(schema=schema)\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:create_app\", factory=True, reload=True)\n</code></pre> <ol> <li>Note that <code>inject</code> is imported from <code>aioinject.ext.strawberry</code></li> </ol>"}]}